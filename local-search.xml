<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>【笔记】二维凸包</title>
    <link href="/2020/12/13/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/"/>
    <url>/2020/12/13/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E4%BA%8C%E7%BB%B4%E5%87%B8%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Part-999-感谢列表"><a href="#Part-999-感谢列表" class="headerlink" title="Part -999 感谢列表"></a>Part -999 感谢列表</h1><p>（排名不分先后）</p><ul><li><a href="https://oi-wiki.org/geometry/">计算几何「OI-Wiki」</a></li><li><a href="https://www.luogu.com.cn/blog/ShineEternal/convex-hull">数论小白都能看懂的平面凸包详解 「ShineEternal的博客」</a></li><li><a href="https://www.geogebra.org/geometry">几何画图「GeoGebra」</a> 离线版</li><li>感谢@rui_er 指出了一个错误</li></ul><h1 id="Part-1-前言"><a href="#Part-1-前言" class="headerlink" title="Part 1 前言"></a>Part 1 前言</h1><p>首先说明一下，<strong>本人是刚学 $\mathsf{OI}$ 的萌新，本学习笔记如有错误，并非有意，但仍然欢迎在讨论去狂 $\sf D$ 她。</strong></p><p>关于图片：<strong>本文所有图片均为作者纯手画。</strong></p><p>祝读者有良好的阅读体验~</p><h1 id="Part-2-何为计算几何"><a href="#Part-2-何为计算几何" class="headerlink" title="Part 2 何为计算几何"></a>Part 2 何为计算几何</h1><p>学二维凸包，我们首先需要了解的就是计算几何。</p><p>计算几何，就是利用计算机建立数学模型解决几何问题。</p><p>要用电脑解几何题？数学好的同学们笑了。</p><p>我们并不是用计算机算数学卷子上的几何题去了，而是解决一些更加复杂的几何相关问题。</p><p>为了解决复杂且抽象的问题，我们一定要选择合适的研究方法。对于计算机来说，给它看几何图形……</p><h1 id="Part-3-二维凸包"><a href="#Part-3-二维凸包" class="headerlink" title="Part 3 二维凸包"></a>Part 3 二维凸包</h1><h3 id="Part-3-1-凸多边形"><a href="#Part-3-1-凸多边形" class="headerlink" title="Part 3.1 凸多边形"></a>Part 3.1 凸多边形</h3><p>凸多边形是指所有内角大小都在 $[0, \pi]$ 范围内的 <strong>简单多边形</strong> 。</p><h3 id="Part-3-2-凸包"><a href="#Part-3-2-凸包" class="headerlink" title="Part 3.2 凸包"></a>Part 3.2 凸包</h3><p>「</p><p>在平面上能包含所有给定点的最小凸多边形叫做凸包。</p><p>其定义为：对于给定集合 $X$ ，所有包含 $X$ 的凸集的交集 $S$ 被称为 $X$ 的 <strong>凸包</strong> 。</p><p>$\qquad\qquad$ —— OI-Wiki</p><p>」</p><p>其实我们可以把凸包看成一个拿橡皮筋围成的一个图形。</p><p>假设有一个布满小凸起的板子：</p><p><img src="https://i.loli.net/2020/06/30/A6ShNCfbpdqDsek.png" alt="3.1.2-1"></p><p>我们要把这些凸起都围起来，怎么围呢？</p><p>显然，最简单方变的方法是这样：</p><p><img src="https://i.loli.net/2020/06/30/DrdGHORmJyuP63b.png" alt="3.1.2-2"></p><p>但是，我们知道，橡皮筋是有弹力的，所以橡皮筋会往里缩，直到这样：</p><p><img src="https://i.loli.net/2020/06/30/qOfrU8Ga7Bp4zZX.png" alt="3.1.2-3"></p><p>最外圈的凸起撑起了橡皮筋。</p><p>此时橡皮筋围成的多边形的顶点就是最外圈凸起所在的位置。</p><p>由此，我们就定义橡皮筋围成的图形为一个平面凸包。</p><p>那么，换一种定义，就为：</p><p><strong>平面凸包是指覆盖平面上 $n$ 个点的最小的凸多边形。</strong></p><p>当然，我们发现在程序中却无法模拟橡皮筋收缩的过程，于是有了下文的诞生。</p><h3 id="Part-3-3-二维凸包的求法"><a href="#Part-3-3-二维凸包的求法" class="headerlink" title="Part 3.3 二维凸包的求法"></a>Part 3.3 二维凸包的求法</h3><p>在这里我们只讲两种主要的也是最常用的二维凸包的求法。</p><h4 id="Part-3-3-1-Graham-算法"><a href="#Part-3-3-1-Graham-算法" class="headerlink" title="Part 3.3.1 Graham 算法"></a>Part 3.3.1 Graham 算法</h4><p>Graham 算法的本质：</p><p>Graham 扫描算法维护一个凸壳，通过不断在凸壳中加入新的点和去除影响凸性的点，最后形成凸包。</p><p>凸壳：凸包的一部分。</p><p>此算法主要分为两部分：</p><ul><li>排序</li><li>扫描</li></ul><h5 id="Part-3-3-1-1-排序"><a href="#Part-3-3-1-1-排序" class="headerlink" title="Part 3.3.1.1 排序"></a>Part 3.3.1.1 排序</h5><p>我们先选择一个 $y$ 最小的点（如 $y$ 相同选 $x$ 最小），记为 $p_1$。</p><p>剩下的点，按照极角的大小逆时针排序，记为 $p_2,p_3,\dots, p_m$。</p><p><img src="https://i.loli.net/2020/06/30/Xi7cFNM1P9GgbOn.png" alt="3.1.3.3.1-1"></p><h5 id="Part-3-3-1-2-扫描"><a href="#Part-3-3-1-2-扫描" class="headerlink" title="Part 3.3.1.2 扫描"></a>Part 3.3.1.2 扫描</h5><p>（下列所说的左右等是指以上一条连线为铅垂线，新的连线偏移的方向）</p><p>刚开始，我们的点集是这样的：</p><p><img src="https://i.loli.net/2020/06/30/TbHLPcV94xvrKtO.png" alt="3.1.3.3.1-2"></p><p>$p_1$ 为起始点。</p><p>随后，$p_2$ 准备入栈，由于栈元素很少，所以可以入栈。</p><p><img src="https://i.loli.net/2020/07/01/hpnwUIfumRPDcj8.png" alt="3.1.3.3.1-3"></p><p>再看 $p_3$，因为 $p_3$ 向左，符合凸包条件，入栈。</p><p><img src="https://i.loli.net/2020/07/01/CPjer9L8yaI7KVl.png" alt="3.1.3.3.1-4"></p><p>随后 $p_4$ 也一切正常，依然向左，入栈。</p><p><img src="https://i.loli.net/2020/07/01/u2rv43QySIpP5tl.png" alt="3.1.3.3.1-5"></p><p>$p_5$ 依然向左，入栈。</p><p><img src="https://i.loli.net/2020/07/01/tiaQTMcZ1AYKeBj.png" alt="3.1.3.3.1-6"></p><p>到 $p_6$ 时，我们发现了点问题，就是不再是向左了，而是向右了，所以我们此时要将 $p_5$ 出栈，$p_6$ 入栈。</p><p><img src="https://i.loli.net/2020/07/01/VpAYBD6cyjNFtlv.png" alt="3.1.3.3.1-7"></p><p>入栈后，我们发现，相对于 $p_4$，$p_6$ 依然是向右的，所以我们还要把 $p_4$ 出栈，$p_6$ 入栈。</p><p><img src="https://i.loli.net/2020/07/01/Hk2a81zh9M3lgZu.png" alt="8"></p><p>接下来 $p_7$ 没有问题。</p><p><img src="https://i.loli.net/2020/07/01/VnQT83rJ1NYfMxB.png" alt="9"></p><p>$p_8$ 时，我们发现，也是向右的，所以将 $p_7$ 出栈，$p_8$ 入栈。</p><p><img src="https://i.loli.net/2020/07/01/QlEoV249qyeuGNi.png" alt="10"></p><p>接下来 $p_9$ 正常，入栈。</p><p><img src="https://i.loli.net/2020/07/01/lRch9fBSgmKanIY.png" alt="11"></p><p>最后，我们再把最后一个点和第一个点连起来。</p><p><img src="https://i.loli.net/2020/07/01/1YmXwVn3bKZESPf.png" alt="12"></p><p>此时，我们的 Graham 算法的全过程就结束了。</p><p>时间复杂度为 $O(n \log n)$。</p><h4 id="Part-3-3-2-Andrew-算法"><a href="#Part-3-3-2-Andrew-算法" class="headerlink" title="Part 3.3.2 Andrew 算法"></a>Part 3.3.2 Andrew 算法</h4><p>Graham 算法的一种进阶。</p><p>假设我们有这些点：</p><p><img src="https://i.loli.net/2020/07/04/uOSnAyoZxvQ6i1m.png" alt="1.PNG"></p><p>首先把所有点以横坐标为第一关键字，纵坐标为第二关键字排序。</p><p><img src="https://i.loli.net/2020/07/04/YUM73eF68o1nR9s.png" alt="2.PNG"></p><p>相对于 Graham 算法来说，Andrew 算法排序更简单，按 $x, y$ 坐标排序，时间复杂度也更低（一般的坐标系中排序方法）。</p><p>首先将 $p_1$ 入栈。</p><p>然后也将 $p_2$ 入栈，$p_2$ 可能在，也可能不在，等着之后判断。</p><p><img src="https://i.loli.net/2020/07/04/DKdpPlJaeZwRhfW.png" alt="3.PNG"></p><p>随后，发现 $p_3$ 偏右，所以我们将 $p_2$ 出栈。</p><p><img src="https://i.loli.net/2020/07/04/USeLAwsWEcFTRrC.png" alt="4.PNG"></p><p>发现 $p_4$ 依然偏右，$p_3$ 出栈，$p_4$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/g7AoVBTYiaZ321L.png" alt="5.PNG"></p><p>$p_5$ 向右，$p_4$ 出栈，$p_5$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/5JOMiGuL4sNQxvl.png" alt="6.PNG"></p><p>$p_6$ 向左，入栈。</p><p><img src="https://i.loli.net/2020/07/04/kCTPOfo3riNyHlg.png" alt="7.PNG"></p><p>$p_7$ 向右，$p_6$ 出栈，$p_7$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/dijDV6uptSyoRLA.png" alt="8.PNG"></p><p>$p_8$ 向右，$p_7$ 出栈，继续检查发现相对于 $p_5$ $p_8$ 仍然向右，$p_5$ 出栈，$p_8$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/bnNZufIchUpgLrB.png" alt="9.PNG"></p><p>此时，我们发现，凸包空了一半。</p><p>所以我们需要再从排序末尾的点（也就是 $p_8$）出发，按照一模一样的方式再算一遍就行了。</p><p>当然如果我们走过的点就不许要再走了（除了 $p_1$）.</p><p>从 $p_8$ 到 $p_7$，向左，$p_7$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/qpacvPJSXFw4xLe.png" alt="10.PNG"></p><p>$p_6$ 向右，$p_7$ 出栈，$p_6$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/HnIWFlVYem8ZtpE.png" alt="11.PNG"></p><p>$p_5$ 向左，入栈。</p><p><img src="https://i.loli.net/2020/07/04/kTe6FJpUr2avZAq.png" alt="12.PNG"></p><p>$p_4$ 向左，入栈。</p><p><img src="https://i.loli.net/2020/07/04/9XaUIrDHmnbAu3z.png" alt="13.PNG"></p><p>$p_3$ 向右，$p_4$ 出栈，对于 $p_5$ $p_3$ 依然向右，$p_5$ 出栈，$p_3$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/bKdQ8OHAMGpCF7g.png" alt="14.PNG"></p><p>$p_2$ 向右，$p_3$ 出栈，$p_2$ 入栈。</p><p><img src="https://i.loli.net/2020/07/04/acmeX41uHwIDonA.png" alt="15.PNG"></p><p>最后将 $p_2$ 和 $p_1$ 连起来。</p><p><img src="https://i.loli.net/2020/07/04/sB4igz6oZ9hUbCT.png" alt="16.PNG"></p><p>至此，我们的 Andrew 算法就完成了！</p><p>时间复杂度：$O(n \log n)$</p><h3 id="Part-3-4-实战演练"><a href="#Part-3-4-实战演练" class="headerlink" title="Part 3.4 实战演练"></a>Part 3.4 实战演练</h3><h4 id="Part-3-4-1-P2742-USACO5-1-圈奶牛Fencing-the-Cows-【模板】二维凸包"><a href="#Part-3-4-1-P2742-USACO5-1-圈奶牛Fencing-the-Cows-【模板】二维凸包" class="headerlink" title="Part 3.4.1 P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包"></a>Part 3.4.1 <a href="https://www.luogu.com.cn/problem/P2742">P2742 [USACO5.1]圈奶牛Fencing the Cows /【模板】二维凸包</a></h4><p>先拿模板题练练手。</p><p>题目简述：求一个二维凸包的周长。</p><p>拿 Graham 算法做即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> <span class="hljs-meta-keyword">line</span> cout &lt;&lt; endl</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NR = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-keyword">double</span> ans;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br><span class="hljs-keyword">double</span> x, y;<br>&#125;;<br>point p[NR], ps[NR];<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span> <span class="hljs-params">(point pa, point pb)</span> </span>&#123; <span class="hljs-comment">//求两点间距离</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span> ((pb.x - pa.x) * (pb.x - pa.x) + (pb.y - pa.y) * (pb.y - pa.y));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cp</span> <span class="hljs-params">(point pa1, point pa2, point pb1, point pb2)</span> </span>&#123; <span class="hljs-comment">//求叉积</span><br><span class="hljs-keyword">return</span> (pa2.x - pa1.x) * (pb2.y - pb1.y) - (pb2.x - pb1.x) * (pa2.y - pa1.y);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(point px, point py)</span> </span>&#123; <span class="hljs-comment">//排序</span><br><span class="hljs-keyword">double</span> num = cp (p[<span class="hljs-number">1</span>], px, p[<span class="hljs-number">1</span>], py);<br><span class="hljs-keyword">if</span> (num &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (num == <span class="hljs-number">0</span> &amp;&amp; dis (p[<span class="hljs-number">0</span>], px) &lt; dis (p[<span class="hljs-number">0</span>], py)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; n;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br><span class="hljs-built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y;<br><span class="hljs-keyword">if</span>(i != <span class="hljs-number">1</span> &amp;&amp; p[i].y &lt; p[<span class="hljs-number">1</span>].y) &#123; <span class="hljs-comment">//去重</span><br>swap (p[i].y, p[<span class="hljs-number">1</span>].y);<br>swap (p[i].x, p[<span class="hljs-number">1</span>].x);<br>        &#125;<br>&#125;<br>sort (p + <span class="hljs-number">2</span>, p + n + <span class="hljs-number">1</span>, cmp);<br>ps[<span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">//最低点是肯定在凸包里的</span><br><span class="hljs-keyword">int</span> h = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br><span class="hljs-keyword">while</span> (h &gt; <span class="hljs-number">1</span> &amp;&amp; cp (ps[h - <span class="hljs-number">1</span>], ps[h], ps[h], p[i]) &lt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//判断是向左还是向右，如果向右就出栈</span><br>h--;<br>&#125;<br>h++;<br>ps[h] = p[i];<br>&#125;<br>ps[h + <span class="hljs-number">1</span>] = p[<span class="hljs-number">1</span>]; <span class="hljs-comment">//最后一个点跟第一个点相连</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= h; i++) &#123;<br>ans += dis (ps[i], ps[i + <span class="hljs-number">1</span>]); <span class="hljs-comment">//累加</span><br>&#125;<br><span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%.2lf\n&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Part-3-4-2-UVA11626-Convex-Hull"><a href="#Part-3-4-2-UVA11626-Convex-Hull" class="headerlink" title="Part 3.4.2 UVA11626 Convex Hull"></a>Part 3.4.2 <a href="https://www.luogu.com.cn/problem/UVA11626">UVA11626 Convex Hull</a></h4><p>这题好像拿 Graham 会 TLE？拿 Andrew罢，也是道模板题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> <span class="hljs-meta-keyword">line</span> cout &lt;&lt; endl</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> NR = <span class="hljs-number">1e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> eps = <span class="hljs-number">1e-7</span>;<br><span class="hljs-keyword">int</span> n;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point</span> &#123;</span><br>    <span class="hljs-keyword">double</span> x, y;<br>    point () &#123;&#125;<br>    point (<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b) : x (a), y (b) &#123;&#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-keyword">const</span> point &amp;b) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; b.x) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (x &gt; b.x) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> y &lt; b.y;<br>    &#125;<br>    point <span class="hljs-keyword">operator</span> - (<span class="hljs-keyword">const</span> point &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> point (x - b.x, y - b.y);<br>    &#125;<br>&#125;;<br>point p[NR], sp[NR];<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">cmp</span> <span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">fabs</span> (x) &lt; eps) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> x &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">-1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">dis</span> <span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sqrt</span> ((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">double</span> <span class="hljs-title">cp</span> <span class="hljs-params">(point a, point b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a.x * b.y - a.y * b.x;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Andrew</span> <span class="hljs-params">()</span> </span>&#123;<br>    sort (p + <span class="hljs-number">1</span>, p + <span class="hljs-number">1</span> + n);<br>    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">1</span> &amp;&amp; cmp (cp (sp[len] - sp[len - <span class="hljs-number">1</span>], p[i] - sp[len - <span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>) <br>            len--;<br>        sp[++len] = p[i];<br>    &#125;<br>    <span class="hljs-keyword">int</span> k = len;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (len &gt; k &amp;&amp; cmp (cp (sp[len] - sp[len - <span class="hljs-number">1</span>], p[i] - sp[len - <span class="hljs-number">1</span>])) &lt; <span class="hljs-number">0</span>)<br>            len--;<br>        sp[++len] = p[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> len;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> t;<br>    <span class="hljs-built_in">cin</span> &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        <span class="hljs-built_in">cin</span> &gt;&gt; n;<br>        <span class="hljs-keyword">char</span> c;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>            <span class="hljs-built_in">cin</span> &gt;&gt; p[i].x &gt;&gt; p[i].y &gt;&gt; c;<br>        <span class="hljs-keyword">int</span> t = Andrew();<br>        <span class="hljs-built_in">cout</span> &lt;&lt; t - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; t; i++) <br>            <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;%.0lf %.0lf\n&quot;</span>, sp[i].x, sp[i].y);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>The End…</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记, 二维图包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>first!</title>
    <link href="/2020/12/13/first/"/>
    <url>/2020/12/13/first/</url>
    
    <content type="html"><![CDATA[<h1 id="First-Post"><a href="#First-Post" class="headerlink" title="First Post!"></a>First Post!</h1><p>$test$</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2020/12/13/hello-world/"/>
    <url>/2020/12/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
